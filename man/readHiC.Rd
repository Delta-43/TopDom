% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/readHiC.R
\name{readHiC}
\alias{readHiC}
\title{Reads a Hi-C contact data file}
\usage{
readHiC(file, chr = NULL, binSize = NULL,
  debug = getOption("TopDom.debug", FALSE))
}
\arguments{
\item{file}{The pathname of a normalize Hi-C contact matrix file
stored as a whitespace-delimited file.  See below for details.
Also a gzip-compressed file can be used.}

\item{chr, binSize}{If the file contains a count matrix without bin
annotation, the latter is created from these parameters.}

\item{debug}{If \code{TRUE}, debug output is produced.}
}
\value{
A list with elements \code{bins} (an N-by-4 data.frame) and
\code{counts} (N-by-N matrix).
}
\description{
Reads a Hi-C contact data file
}
\section{Format of HiC contact-matrix file}{

The contact-matrix file should be a whitespace-delimited text file with
neither row names nor column names.  The content should be a N-by-(3+N)
table where the first three columns correspond to \code{chr} (string),
\code{from.coord} (integer position), and \code{to.coord} (integer position).
These column defines the genomic location of the N Hi-C bins (in order).
The last N columns should contain normalized contact counts (float) such
that element (r, 3+c) in this table corresponds to count (r,c) in the
normalized contact matrix.

If an N-by-(4+N) table, then the first column is assumed to contain an
\code{id} (integer), and everything else as above.

Example:
\preformatted{
  chr10       0   40000  0 0 0 0 ...
  chr10   40000   80000  0 0 0 0 ...
  chr10   80000  120000  0 0 0 0 ...
  chr10  120000  160000  0 0 0 0 ...
  ...
}
}

\examples{
if (require("TopDomData")) {
  path <- system.file("exdata", package = "TopDomData", mustWork = TRUE)

  ## Original count data
  pathname <- file.path(path, "nij.chr10.gz")
  data <- readHiC(pathname, chr = "chr10", binSize = 40e3)
  print(data)  ## a TopDomData object

  ## Find topological domains using the TopDom method
  fit <- TopDom(data, window.size = 5L)
  print(fit)  ## a TopDom object

  ## Display the largest domain
  td <- subset(subset(fit$domain, tag == "domain"), size == max(size))
  print(td) ## a data.frame

  data_s <- subsetByRegion(data, region = td, margin = 0.9999)
  print(data_s)  ## a TopDomData object
  
  vp <- grid::viewport(angle = -45, width = 0.7, y = 0.1)
  gg <- ggCountHeatmap(data_s)
  gg <- gg + ggDomain(td, color = "#cccc00") + ggDomainLabel(td)
  print(gg, newpage = TRUE, vp = vp)

  gg <- ggCountHeatmap(data_s, colors = list(mid = "white", high = "black"))
  gg <- gg + ggDomain(td) + ggDomainLabel(td)
  gg <- gg + ggDomain(td, vline = 2)
  print(gg, newpage = TRUE, vp = vp)

  fit_s <- subsetByRegion(fit, region = td, margin = 0.9999)
  dx <- 0.04 * (td$to.coord - td$from.coord)
  print(fit_s)  ## a TopDom object
  for (kk in seq_len(nrow(fit_s$domain))) {
    gg <- gg + ggDomain(fit_s$domain[kk, ], dx = dx * (2 + kk \%\% 2), color = "red", size = 1)
  }

  print(gg, newpage = TRUE, vp = vp)
}
}
\seealso{
\link{TopDom}.
}
